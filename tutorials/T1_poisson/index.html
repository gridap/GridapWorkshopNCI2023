<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <script src="/GridapWorkshopNCI2023/libs/lunr/lunr.min.js"></script> <script src="/GridapWorkshopNCI2023/libs/lunr/lunr_index.js"></script> <script src="/GridapWorkshopNCI2023/libs/lunr/lunrclient.min.js"></script> <link rel=stylesheet  href="/GridapWorkshopNCI2023/libs/katex/katex.min.css"> <link rel=stylesheet  href="/GridapWorkshopNCI2023/libs/highlight/github.min.css"> <link rel=stylesheet  href="/GridapWorkshopNCI2023/css/franklin.css"> <link rel=stylesheet  href="/GridapWorkshopNCI2023/css/poole_hyde.css"> <link rel=stylesheet  href="/GridapWorkshopNCI2023/css/custom.css"> <style> html {font-size: 17px;} .franklin-content {position: relative; padding-left: 8%; padding-right: 5%; line-height: 1.35em;} @media (min-width: 940px) { .franklin-content {width: 100%; margin-left: auto; margin-right: auto;} } @media (max-width: 768px) { .franklin-content {padding-left: 6%; padding-right: 6%;} } </style> <link rel=apple-touch-icon  sizes=152x152  href="/GridapWorkshopNCI2023/assets/favicon/apple-touch-icon.png"> <link rel=icon  type="image/png" sizes=32x32  href="/GridapWorkshopNCI2023/assets/favicon/favicon-32x32.png"> <link rel=icon  type="image/png" sizes=16x16  href="/GridapWorkshopNCI2023/assets/favicon/favicon-16x16.png"> <link rel=manifest  href="/GridapWorkshopNCI2023/assets/favicon/site.webmanifest"> <link rel=mask-icon  href="/GridapWorkshopNCI2023/assets/favicon/safari-pinned-tab.svg" color="#5bbad5"> <meta name=msapplication-TileColor  content="#da532c"> <meta name=theme-color  content="#ffffff"> <title>Poisson tutorial</title> <style> .content {max-width: 60rem} </style> <div class=sidebar > <div class="container sidebar-sticky"> <div class=sidebar-about > <img src="/GridapWorkshopNCI2023/assets/logos.png" style="width: 500px; height: auto; display: inline"> <div style="font-weight: margin-bottom: 0.5em"><a href="/GridapWorkshopNCI2023/">28-29th, November, 2023</a> <span style="opacity: 0.9;">| Australian National University, Canberra</span></div> <br> <h1><a href="/GridapWorkshopNCI2023/">Introduction to Gridap: Simulating PDEs using finite elements in Julia</a></h1> <div style="line-height:18px; font-size: 15px; opacity: 0.85">by &nbsp; <a href="https://research.monash.edu/en/persons/santiago-badia">Santiago Badia</a>, &nbsp; <a href="https://amartinhuertas.github.io/">Alberto F. Martin</a>, &nbsp; <a href="https://github.com/JordiManyer">Jordi Manyer</a> </div> </div> <br> <style> </style> <nav class=sidebar-nav  style="opacity: 0.9; margin-bottom: 1.2cm;"> <a class="sidebar-nav-item " href="/GridapWorkshopNCI2023/"><b>Welcome</b></a> <a class="sidebar-nav-item " href="/GridapWorkshopNCI2023/software_install/">Software install instructions</a> <a class="sidebar-nav-item " href="/GridapWorkshopNCI2023/tutorials/">Tutorials</a> <a class="sidebar-nav-item " href="/GridapWorkshopNCI2023/references/">References</a> <a class="sidebar-nav-item " href="/GridapWorkshopNCI2023/grants/">Registration and grants for research students</a> <a class="sidebar-nav-item " href="/GridapWorkshopNCI2023/flyer/">Event Flyer</a> <br> <div class=course-section >Part 1 - Introduction to the finite element method</div> <a class="sidebar-nav-item " href="/GridapWorkshopNCI2023/lecture1/">Tutorial 1 - TBA</a> <div class=course-section >Part 2 - TBA</div> <div class=course-section >Part 3 - TBA</div> </nav> <form id=lunrSearchForm  name=lunrSearchForm > <input class=search-input  name=q  placeholder="Enter search term" type=text > <input type=submit  value=Search  formaction="/GridapWorkshopNCI2023/search/index.html"> </form> <br> <br> </div> </div> <div class="content container"> <div class=franklin-content > <h1 id=poisson_tutorial ><a href="#poisson_tutorial" class=header-anchor >Poisson tutorial</a></h1> <p>In this tutorial, we will learn</p> <ul> <li><p>How to solve a simple PDE in Julia with Gridap</p> <li><p>How to build a conforming scalar Lagrangian FE space</p> <li><p>How to define the different terms in a weak form</p> <li><p>How to impose Dirichlet and Neumann boundary conditions</p> <li><p>How to visualize results</p> <li><p>How to compute and plot convergence rates</p> </ul> <h2 id=problem_statement ><a href="#problem_statement" class=header-anchor >Problem statement</a></h2> <p>In this first tutorial, we provide an overview of a complete simulation pipeline in Gridap: from the construction of the FE mesh to the visualization of the computed results. To this end, we consider a simple model problem: the Poisson equation.</p> <p>We want to solve the Poisson equation on the 3D cartesian domain <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy=false >[</mo><mo>−</mo><mi>π</mi><mo separator=true >,</mo><mi>π</mi><mo stretchy=false >]</mo><mo>×</mo><mo stretchy=false >[</mo><mo>−</mo><mi>π</mi><mi mathvariant=normal >/</mi><mn>2</mn><mo separator=true >,</mo><mi>π</mi><mi mathvariant=normal >/</mi><mn>2</mn><mo stretchy=false >]</mo><mo>×</mo><mo stretchy=false >[</mo><mn>0</mn><mo separator=true >,</mo><mn>1</mn><mo stretchy=false >]</mo></mrow><annotation encoding="application/x-tex">[-\pi,\pi]\times[-\pi/2,\pi/2]\times[0,1]</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >[</span><span class=mord >−</span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class=mclose >]</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >×</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >[</span><span class=mord >−</span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class=mord >/</span><span class=mord >2</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class=mord >/</span><span class=mord >2</span><span class=mclose >]</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >×</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >[</span><span class=mord >0</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mord >1</span><span class=mclose >]</span></span></span></span> with Dirichlet and Neumann boundary conditions. Dirichlet boundary conditions are applied on <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant=normal >Γ</mi><mi mathvariant=normal >D</mi></msub><mo>=</mo><mo stretchy=false >{</mo><mi>z</mi><mo>=</mo><mn>0</mn><mo stretchy=false >}</mo><mo>∪</mo><mo stretchy=false >{</mo><mi>z</mi><mo>=</mo><mn>1</mn><mo stretchy=false >}</mo></mrow><annotation encoding="application/x-tex">\Gamma_{\rm D} = \{ z = 0 \} \cup \{ z = 1 \}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.83333em;vertical-align:-0.15em;"></span><span class=mord ><span class=mord >Γ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">D</span></span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >{</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mord >0</span><span class=mclose >}</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >∪</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >{</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mord >1</span><span class=mclose >}</span></span></span></span>, i.e the bottom and top boundaries. Non-homogeneous Neumann conditions are applied everywhere else, i.e <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant=normal >Γ</mi><mi mathvariant=normal >N</mi></msub><mo>=</mo><mo stretchy=false >{</mo><mi>x</mi><mo>=</mo><mo>−</mo><mi>π</mi><mo stretchy=false >}</mo><mo>∪</mo><mo stretchy=false >{</mo><mi>x</mi><mo>=</mo><mi>π</mi><mo stretchy=false >}</mo><mo>∪</mo><mo stretchy=false >{</mo><mi>y</mi><mo>=</mo><mo>−</mo><mi>π</mi><mi mathvariant=normal >/</mi><mn>2</mn><mo stretchy=false >}</mo><mo>∪</mo><mo stretchy=false >{</mo><mi>y</mi><mo>=</mo><mi>π</mi><mi mathvariant=normal >/</mi><mn>2</mn><mo stretchy=false >}</mo></mrow><annotation encoding="application/x-tex">\Gamma_{\rm N} = \{ x = -\pi \} \cup \{ x = \pi \} \cup \{ y = -\pi/2 \} \cup \{ y = \pi/2 \}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.83333em;vertical-align:-0.15em;"></span><span class=mord ><span class=mord >Γ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">N</span></span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >{</span><span class="mord mathnormal">x</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mord >−</span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class=mclose >}</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >∪</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >{</span><span class="mord mathnormal">x</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class=mclose >}</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >∪</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >{</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mord >−</span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class=mord >/</span><span class=mord >2</span><span class=mclose >}</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >∪</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >{</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class=mord >/</span><span class=mord >2</span><span class=mclose >}</span></span></span></span>.</p> <p>Formally, the problem to solve is: find the scalar field <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi></mrow><annotation encoding="application/x-tex">u</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">u</span></span></span></span> such that</p> <span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mrow><mo fence=true >{</mo><mtable rowspacing=0.24999999999999992em  columnalign="right left" columnspacing=0em ><mtr><mtd><mstyle scriptlevel=0  displaystyle=true ><mrow><mo>−</mo><mi mathvariant=normal >Δ</mi><mi>u</mi><mo>=</mo><mi>f</mi><mtext> </mtext></mrow></mstyle></mtd><mtd><mstyle scriptlevel=0  displaystyle=true ><mrow><mrow></mrow><mtext>in </mtext><mi mathvariant=normal >Ω</mi><mo separator=true >,</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=0  displaystyle=true ><mrow><mi>u</mi><mo>=</mo><mi>g</mi><mtext> </mtext></mrow></mstyle></mtd><mtd><mstyle scriptlevel=0  displaystyle=true ><mrow><mrow></mrow><mtext>on </mtext><msub><mi mathvariant=normal >Γ</mi><mi mathvariant=normal >D</mi></msub><mo separator=true >,</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel=0  displaystyle=true ><mrow><mi mathvariant=normal >∇</mi><mi>u</mi><mo>⋅</mo><mi>n</mi><mo>=</mo><mi>h</mi><mtext> </mtext></mrow></mstyle></mtd><mtd><mstyle scriptlevel=0  displaystyle=true ><mrow><mrow></mrow><mtext>on </mtext><msub><mi mathvariant=normal >Γ</mi><mi mathvariant=normal >N</mi></msub><mo separator=true >,</mo></mrow></mstyle></mtd></mtr></mtable></mrow><annotation encoding="application/x-tex"> \left\lbrace \begin{aligned} -\Delta u = f \ &amp;\text{in} \ \Omega,\\ u = g \ &amp;\text{on}\ \Gamma_{\rm D},\\ \nabla u\cdot n = h \ &amp;\text{on}\ \Gamma_{\rm N},\\ \end{aligned} \right. </annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:4.500000000000002em;vertical-align:-2.000000000000001em;"></span><span class=minner ><span class=mopen ><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:2.35002em;"><span style="top:-2.19999em;"><span class=pstrut  style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.19499em;"><span class=pstrut  style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.20499em;"><span class=pstrut  style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.15001em;"><span class=pstrut  style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.2950099999999996em;"><span class=pstrut  style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.30501em;"><span class=pstrut  style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.60002em;"><span class=pstrut  style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:1.8500199999999998em;"><span></span></span></span></span></span></span><span class=mord ><span class=mtable ><span class=col-align-r ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:2.5000000000000004em;"><span style="top:-4.66em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mord >−</span><span class=mord >Δ</span><span class="mord mathnormal">u</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class=mspace > </span></span></span><span style="top:-3.16em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class="mord mathnormal">u</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class=mspace > </span></span></span><span style="top:-1.6599999999999993em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mord >∇</span><span class="mord mathnormal">u</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >⋅</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal">n</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal">h</span><span class=mspace > </span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:2.000000000000001em;"><span></span></span></span></span></span><span class=col-align-l ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:2.5000000000000004em;"><span style="top:-4.66em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mord ></span><span class="mord text"><span class=mord >in</span></span><span class=mspace > </span><span class=mord >Ω</span><span class=mpunct >,</span></span></span><span style="top:-3.16em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mord ></span><span class="mord text"><span class=mord >on</span></span><span class=mspace > </span><span class=mord ><span class=mord >Γ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">D</span></span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mpunct >,</span></span></span><span style="top:-1.6599999999999993em;"><span class=pstrut  style="height:3em;"></span><span class=mord ><span class=mord ></span><span class="mord text"><span class=mord >on</span></span><span class=mspace > </span><span class=mord ><span class=mord >Γ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">N</span></span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mpunct >,</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:2.000000000000001em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span> <p>being <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> the outwards unit normal vector to the Neumann boundary <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant=normal >Γ</mi><mi mathvariant=normal >N</mi></msub></mrow><annotation encoding="application/x-tex">\Gamma_{\rm N}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.83333em;vertical-align:-0.15em;"></span><span class=mord ><span class=mord >Γ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">N</span></span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>. In this tutorial, we will try to recover an analytical solution <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo stretchy=false >(</mo><mi>x</mi><mo separator=true >,</mo><mi>y</mi><mo separator=true >,</mo><mi>z</mi><mo stretchy=false >)</mo><mo>=</mo><mi>c</mi><mi>o</mi><mi>s</mi><mo stretchy=false >(</mo><mi>x</mi><mo stretchy=false >)</mo><mo>∗</mo><mi>s</mi><mi>i</mi><mi>n</mi><mo stretchy=false >(</mo><mi>y</mi><mo>+</mo><mi>π</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">u(x,y,z) = cos(x)*sin(y+π)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">u</span><span class=mopen >(</span><span class="mord mathnormal">x</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">o</span><span class="mord mathnormal">s</span><span class=mopen >(</span><span class="mord mathnormal">x</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >∗</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">n</span><span class=mopen >(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class=mclose >)</span></span></span></span> and analyze the convergence rates of our numerical approximation.</p> <h2>Numerical scheme</h2> <p>To solve this PDE, we use a conventional Galerkin finite element &#40;FE&#41; method with conforming Lagrangian FE spaces &#40;see, e.g., &#91;1&#93; for specific details on this formulation&#41;. The weak form associated with this formulation is: find <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>u</mi><mo>∈</mo><mi>U</mi></mrow><annotation encoding="application/x-tex">u\in U</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">u</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >∈</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span> such that <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mo stretchy=false >(</mo><mi>u</mi><mo separator=true >,</mo><mi>v</mi><mo stretchy=false >)</mo><mo>=</mo><mi>l</mi><mo stretchy=false >(</mo><mi>v</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex"> a(u,v) = l(v) </annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class=mopen >(</span><span class="mord mathnormal">u</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class=mopen >(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class=mclose >)</span></span></span></span> for all <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mo>∈</mo><mi>V</mi></mrow><annotation encoding="application/x-tex">v\in V</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >∈</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span>, where <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span> and <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> are the subset of functions in <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>H</mi><mn>1</mn></msup><mo stretchy=false >(</mo><mi mathvariant=normal >Ω</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">H^1(\Omega)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.064108em;vertical-align:-0.25em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class=mopen >(</span><span class=mord >Ω</span><span class=mclose >)</span></span></span></span> that fulfill the Dirichlet boundary condition <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi></mrow><annotation encoding="application/x-tex">g</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span></span></span></span> and <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >0</span></span></span></span> respectively. The bilinear and linear forms for this problems are</p> <span class=katex-display ><span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML" display=block ><semantics><mrow><mi>a</mi><mo stretchy=false >(</mo><mi>u</mi><mo separator=true >,</mo><mi>v</mi><mo stretchy=false >)</mo><mo>≐</mo><msub><mo>∫</mo><mi mathvariant=normal >Ω</mi></msub><mi mathvariant=normal >∇</mi><mi>v</mi><mo>⋅</mo><mi mathvariant=normal >∇</mi><mi>u</mi><mtext> </mtext><mi mathvariant=normal >d</mi><mi mathvariant=normal >Ω</mi><mo separator=true >,</mo><mspace width=1em /><mi>l</mi><mo stretchy=false >(</mo><mi>v</mi><mo stretchy=false >)</mo><mo>≐</mo><msub><mo>∫</mo><mi mathvariant=normal >Ω</mi></msub><mi>v</mi><mtext> </mtext><mi>f</mi><mtext> </mtext><mi mathvariant=normal >d</mi><mi mathvariant=normal >Ω</mi><mo>+</mo><msub><mo>∫</mo><msub><mi mathvariant=normal >Γ</mi><mi mathvariant=normal >N</mi></msub></msub><mi>v</mi><mtext> </mtext><mi>h</mi><mtext> </mtext><mi mathvariant=normal >d</mi><msub><mi mathvariant=normal >Γ</mi><mi mathvariant=normal >N</mi></msub><mi mathvariant=normal >.</mi></mrow><annotation encoding="application/x-tex"> a(u,v) \doteq \int_{\Omega} \nabla v \cdot \nabla u \ {\rm d}\Omega, \quad l(v) \doteq \int_{\Omega} v\ f \ {\rm d}\Omega + \int_{\Gamma_{\rm N}} v\ h \ {\rm d}\Gamma_{\rm N}. </annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class=mopen >(</span><span class="mord mathnormal">u</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >≐</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:2.27195em;vertical-align:-0.9119499999999999em;"></span><span class=mop ><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:-0.433619em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mord >∇</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >⋅</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mord >∇</span><span class="mord mathnormal">u</span><span class=mspace > </span><span class=mord ><span class=mord ><span class="mord mathrm">d</span></span></span><span class=mord >Ω</span><span class=mpunct >,</span><span class=mspace  style="margin-right:1em;"></span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class=mopen >(</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class=mclose >)</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >≐</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:2.27195em;vertical-align:-0.9119499999999999em;"></span><span class=mop ><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:-0.433619em;"><span style="top:-1.7880500000000001em;margin-left:-0.44445em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">Ω</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.9119499999999999em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class=mspace > </span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class=mspace > </span><span class=mord ><span class=mord ><span class="mord mathrm">d</span></span></span><span class=mord >Ω</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:2.372255em;vertical-align:-1.012255em;"></span><span class=mop ><span class="mop op-symbol large-op" style="margin-right:0.44445em;position:relative;top:-0.0011249999999999316em;">∫</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:-0.433619em;"><span style="top:-1.7880500000000004em;margin-left:-0.44445em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">Γ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.3448em;"><span style="top:-2.3567071428571427em;margin-left:0em;margin-right:0.07142857142857144em;"><span class=pstrut  style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">N</span></span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.14329285714285717em;"><span></span></span></span></span></span></span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:1.012255em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class=mspace > </span><span class="mord mathnormal">h</span><span class=mspace > </span><span class=mord ><span class=mord ><span class="mord mathrm">d</span></span></span><span class=mord ><span class=mord >Γ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">N</span></span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mord >.</span></span></span></span></span> <p>The problem is solved numerically by approximating the spaces <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span> and <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> by their discrete counterparts associated with a FE mesh of the computational domain <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant=normal >Ω</mi></mrow><annotation encoding="application/x-tex">\Omega</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class=mord >Ω</span></span></span></span>. As we have anticipated, we consider standard conforming Lagrangian FE spaces for this purpose.</p> <p>The implementation of this numerical scheme in Gridap is done in a user-friendly way thanks to the abstractions provided by the library. As it will be seen below, all the mathematical objects involved in the definition of the discrete weak problem have a correspondent representation in the code.</p> <h2>Setup</h2> <p>The step number 0 in order to solve the problem is to load the Gridap library in the code. If you have configured your Julia environment properly, it is simply done with the line:</p> <pre><code class="julia hljs"><span class=hljs-keyword >using</span> Gridap
<span class=hljs-keyword >using</span> DrWatson</code></pre> <p>We define the analytical solution we will try to retrieve as follows</p> <pre><code class="julia hljs">u(x) = cos(x[<span class=hljs-number >1</span>])*sin(x[<span class=hljs-number >2</span>]+<span class=hljs-literal >π</span>)</code></pre>
<h2 id=discrete_model ><a href="#discrete_model" class=header-anchor >Discrete model</a></h2>
<p>As in any FE simulation, we need a discretization of the computational domain &#40;i.e., a FE mesh&#41;. All geometrical data needed for solving a FE problem is provided in Gridap by types inheriting from the abstract type <code>DiscreteModel</code>. In our particular case, we will create a <code>CartesianDiscreteModel</code> of the computational domain <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant=normal >Ω</mi><mo>=</mo><mo stretchy=false >[</mo><mo>−</mo><mi>π</mi><mo separator=true >,</mo><mi>π</mi><mo stretchy=false >]</mo><mo>×</mo><mo stretchy=false >[</mo><mo>−</mo><mi>π</mi><mi mathvariant=normal >/</mi><mn>2</mn><mo separator=true >,</mo><mi>π</mi><mi mathvariant=normal >/</mi><mn>2</mn><mo stretchy=false >]</mo><mo>×</mo><mo stretchy=false >[</mo><mn>0</mn><mo separator=true >,</mo><mn>1</mn><mo stretchy=false >]</mo></mrow><annotation encoding="application/x-tex">\Omega = [-\pi,\pi]\times[-\pi/2,\pi/2]\times[0,1]</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class=mord >Ω</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >[</span><span class=mord >−</span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class=mclose >]</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >×</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >[</span><span class=mord >−</span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class=mord >/</span><span class=mord >2</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class=mord >/</span><span class=mord >2</span><span class=mclose >]</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >×</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mopen >[</span><span class=mord >0</span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mord >1</span><span class=mclose >]</span></span></span></span> with a resolution <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>n</mi><mi>C</mi></msub><mo>=</mo><mo stretchy=false >(</mo><msub><mi>n</mi><mi>x</mi></msub><mo separator=true >,</mo><msub><mi>n</mi><mi>y</mi></msub><mo separator=true >,</mo><msub><mi>n</mi><mi>z</mi></msub><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">n_C=(n_x,n_y,n_z)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.58056em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal">n</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:1.036108em;vertical-align:-0.286108em;"></span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal">n</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mord ><span class="mord mathnormal">n</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.286108em;"><span></span></span></span></span></span></span><span class=mpunct >,</span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mord ><span class="mord mathnormal">n</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.04398em;">z</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span></p>
<pre><code class="julia hljs">domain = (-<span class=hljs-literal >π</span>,<span class=hljs-literal >π</span>,-<span class=hljs-literal >π</span>/<span class=hljs-number >2</span>,<span class=hljs-literal >π</span>/<span class=hljs-number >2</span>,<span class=hljs-number >0</span>,<span class=hljs-number >1</span>)
nC     = (<span class=hljs-number >100</span>,<span class=hljs-number >40</span>,<span class=hljs-number >5</span>)
model  = CartesianDiscreteModel(domain,nC)</code></pre>
<p>By construction, a <code>CartesianDiscreteModel</code> associates with labels every vertex, edge and facet of the model to its parent corner, edge, facet or interior of the grid&#39;s bounding box. Label numbering follows the increasing lexicographic order.</p>
<p>We use this default order to set up the BCs as follows. For convenience, we create two new boundary tags, namely <code>&quot;dirichlet&quot;</code> and <code>&quot;newmann&quot;</code>.</p>
<p>Gridap provides a convenient way to create new object identifiers &#40;referred to as &quot;tags&quot;&#41; from existing ones. First, we need to extract from the model, the object that holds the information about the boundary identifiers &#40;referred to as <code>FaceLabeling</code>&#41;:</p>
<pre><code class="julia hljs">labels = get_face_labeling(model)</code></pre>
<p>Then, we can add new identifiers &#40;aka &quot;tags&quot;&#41; to it. In the next line, we create new tags called <code>&quot;dirichlet&quot;</code> and <code>&quot;newmann&quot;</code> combining the default labels of the model to represent <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant=normal >Γ</mi><mi>D</mi></msub></mrow><annotation encoding="application/x-tex">\Gamma_D</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.83333em;vertical-align:-0.15em;"></span><span class=mord ><span class=mord >Γ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> and <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant=normal >Γ</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">\Gamma_N</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.83333em;vertical-align:-0.15em;"></span><span class=mord ><span class=mord >Γ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> respectively.</p>
<pre><code class="julia hljs">add_tag_from_tags!(labels,<span class=hljs-string >&quot;dirichlet&quot;</span>,[<span class=hljs-string >&quot;tag_21&quot;</span>,<span class=hljs-string >&quot;tag_22&quot;</span>])
add_tag_from_tags!(labels,<span class=hljs-string >&quot;newmann&quot;</span>,[<span class=hljs-string >&quot;tag_23&quot;</span>,<span class=hljs-string >&quot;tag_24&quot;</span>,<span class=hljs-string >&quot;tag_25&quot;</span>,<span class=hljs-string >&quot;tag_26&quot;</span>])</code></pre>
<p>Note the usage of <code>add_tag_from_tags&#33;</code> to construct new boundary tags gathering lower-level tags.</p>
<h2 id=approximation_spaces ><a href="#approximation_spaces" class=header-anchor >Approximation spaces</a></h2>
<pre><code class="julia hljs">order = <span class=hljs-number >1</span>
reffe = ReferenceFE(lagrangian,<span class=hljs-built_in >Float64</span>,order)
V = TestFESpace(model,reffe;conformity=:H1,dirichlet_tags=<span class=hljs-string >&quot;dirichlet&quot;</span>)</code></pre>
<p>Here, we have used the <code>TestFESpace</code> constructor, which constructs a particular FE space &#40;to be used as a test space&#41; from a set of options described as positional and key-word arguments. The first positional argument is the model on top of which we want to build the space. The second positional argument contains information about the type of FE interpolation &#40;the reference FE in this case&#41;. With <code>ReferenceFE&#40;lagrangian,Float64,order&#41;</code> We select a scalar-valued Lagrangian reference FE of order 1, where the value of the shape functions will be represented with  64-bit floating point numbers. With the key-word argument <code>conformity</code> we define the regularity of the interpolation at the boundaries of the cells in the mesh. Here, we use <code>conformity&#61;:H1</code>, which means that the resulting interpolation space is a subset of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>H</mi><mn>1</mn></msup><mo stretchy=false >(</mo><mi mathvariant=normal >Ω</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">H^1(\Omega)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1.064108em;vertical-align:-0.25em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span><span class=mopen >(</span><span class=mord >Ω</span><span class=mclose >)</span></span></span></span> &#40;i.e., continuous shape functions&#41;. On the other hand, we pass the identifiers of the Dirichlet boundary via the <code>dirichlet_tags</code> argument. Since this is a test space, the corresponding shape functions vanishes at the Dirichlet boundary.</p>
<p>Once the space <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span></span></span></span> is discretized in the code, we proceed with the approximation of the trial space <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>U</mi></mrow><annotation encoding="application/x-tex">U</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span></span></span></span>.</p>
<pre><code class="julia hljs">g(x) = u(x)
U = TrialFESpace(V,g)</code></pre>
<p>To this end, we have used the <code>TrialFESpace</code> constructors. Note that we have passed a function representing the value of the Dirichlet boundary condition, when building the trial space &#40;here our analytical solution&#41;.</p>
<h2 id=numerical_integration ><a href="#numerical_integration" class=header-anchor >Numerical integration</a></h2>
<p>Once we have built the interpolation spaces, the next step is to set up the machinery to perform the integrals in the weak form numerically. Here, we need to compute integrals on the interior of the domain <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant=normal >Ω</mi></mrow><annotation encoding="application/x-tex">\Omega</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class=mord >Ω</span></span></span></span> and on the Neumann boundary <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi mathvariant=normal >Γ</mi><mi mathvariant=normal >N</mi></msub></mrow><annotation encoding="application/x-tex">\Gamma_{\rm N}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.83333em;vertical-align:-0.15em;"></span><span class=mord ><span class=mord >Γ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathrm mtight">N</span></span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>. In both cases, we need two main ingredients. We need to define an integration mesh &#40;i.e. a triangulation of the integration domain&#41;, plus a Gauss-like quadrature in each of the cells in the triangulation. In Gridap, integration meshes are represented by types inheriting from the abstract type <code>Triangulation</code>. For integrating on the domain <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant=normal >Ω</mi></mrow><annotation encoding="application/x-tex">\Omega</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.68333em;vertical-align:0em;"></span><span class=mord >Ω</span></span></span></span>, we build the following triangulation and the corresponding Lebesgue measure, which will allow to write down integrals in a syntax similar to the usual mathematical notation.</p>
<pre><code class="julia hljs">degree = order*<span class=hljs-number >2</span>
Ω  = Triangulation(model)
dΩ = Measure(Ω,degree)</code></pre>
<p>Here, we build a triangulation from the cells of the model and build &#40;an approximation of&#41; the Lebesgue measure using a quadrature rule of degree 2 in the cells of this triangulation. This is enough for integrating the corresponding terms of the weak form exactly for an interpolation of order 1.</p>
<p>On the other hand, we need a special type of triangulation, represented by the type <code>BoundaryTriangulation</code>, to integrate on the boundary. Essentially, a <code>BoundaryTriangulation</code> is a particular type of <code>Triangulation</code> that is aware of which cells in the model are touched by faces on the boundary. We build an instance of this type from the discrete model and the names used to identify the Neumann boundary as follows:</p>
<pre><code class="julia hljs">Γ   = BoundaryTriangulation(model,tags=<span class=hljs-string >&quot;newmann&quot;</span>)
dΓ  = Measure(Γ,degree)</code></pre>
<p>In addition, we have created a quadrature of degree 2 on top of the cells in the triangulation for the Neumann boundary.</p>
<p>In order to impose our Newmann boundary conditions, we will need to compute the normal vector to the boundary. This is done with the function <code>get_normal_vector</code>:</p>
<pre><code class="julia hljs">n_Γ = get_normal_vector(Γ)</code></pre>
<h2 id=weak_form ><a href="#weak_form" class=header-anchor >Weak form</a></h2>
<p>With all the ingredients presented so far, we are ready to define the weak form. This is done by defining functions representing the bi-linear and linear forms:</p>
<pre><code class="julia hljs">f(x)   = -Δ(u)(x)
∇u(x)  = ∇(u)(x)
a(u,v) = ∫( ∇(v)⋅∇(u) )*dΩ
l(v)   = ∫( v*f )*dΩ + ∫( v*(∇u⋅n_Γ) )*dΓ</code></pre>
<p>Note that by using the integral function <code>∫</code>, the Lebesgue measures <code>dΩ</code>, <code>dΓ</code>, and the gradient function <code>∇</code>, the weak form is written with an obvious relation with the corresponding mathematical notation.</p>
<h2>FE Problem</h2>
<p>At this point, we can build the FE problem that, once solved, will provide the numerical solution we are looking for. A FE problem is represented in Gridap by types inheriting from the abstract type <code>FEOperator</code> &#40;both for linear and nonlinear cases&#41;. Since we want to solve a linear problem, we use the concrete type <code>AffineFEOperator</code>, i.e., a problem represented by a matrix and a right hand side vector.</p>
<pre><code class="julia hljs">op = AffineFEOperator(a,l,U,V)</code></pre>
<p>Note that the <code>AffineFEOperator</code> object representing our FE problem is built from the function <code>a</code> and <code>l</code> representing the weak form and test and trial FE spaces <code>V</code> and <code>U</code>.</p>
<p>We can also retrieve the matrix and the right hand side vector of the problem as follows:</p>
<pre><code class="julia hljs">A = get_matrix(op)
b = get_vector(op)</code></pre>
<h2>Solver phase</h2>
<p>We have constructed a FE problem, the last step is to solve it. In Gridap, FE problems are solved with types inheriting from the abstract type <code>FESolver</code>. Since this is a linear problem, we use a <code>LinearFESolver</code>:</p>
<pre><code class="julia hljs">ls = LUSolver()
solver = LinearFESolver(ls)</code></pre>
<p><code>LinearFESolver</code> objects are built from a given algebraic linear solver. In this case, we use a LU factorization. Now we are ready to solve the FE problem with the FE solver as follows:</p>
<pre><code class="julia hljs">uh = solve(solver,op)</code></pre>
<p>The <code>solve</code> function returns the computed numerical solution <code>uh</code>. This object is an instance of <code>FEFunction</code>, the type used to represent a function in a FE space. <code>FEFunction</code> is part of the <code>CellField</code> abstract type, which are objects that represent fields over a triangulated domain. We can inspect the result by writing it into a <code>vtk</code> file:</p>
<pre><code class="julia hljs">writevtk(Ω,datadir(<span class=hljs-string >&quot;poisson_sol&quot;</span>),cellfields=[<span class=hljs-string >&quot;uh&quot;</span>=&gt;uh])</code></pre>
<p>which will generate a file named <code>poisson_sol.vtu</code> having a nodal field named <code>&quot;uh&quot;</code> containing the solution of our problem &#40;see next figure&#41;.</p>
<p><img src="../../assets/literate_figures/poisson/fig_uh.png" alt="" /></p>
<p>Additionaly, we can compute the L2 error of the numerical solution as follows:</p>
<pre><code class="julia hljs">e = uh - u
l2_error = sum(∫(e⋅e)*dΩ)</code></pre>
<h2 id=convergence_analysis ><a href="#convergence_analysis" class=header-anchor >Convergence analysis</a></h2>
<p>One of the advantages of having an analytical solution is that we can compute the convergence rates of our numerical approximation. The first step is to define a driver by putting together all the steps described above. The driver takes two arguments: the number of cells in the <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> and <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> direction, <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>, and the order of the finite-element interpolation, <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span></span></span></span>. It returns the L2 error of the numerical solution.</p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> driver(n,order)
  domain = (-<span class=hljs-literal >π</span>,<span class=hljs-literal >π</span>,-<span class=hljs-literal >π</span>/<span class=hljs-number >2</span>,<span class=hljs-literal >π</span>/<span class=hljs-number >2</span>,<span class=hljs-number >0</span>,<span class=hljs-number >1</span>)
  nC     = (n,n,<span class=hljs-number >1</span>)
  model  = CartesianDiscreteModel(domain,nC)
  labels = get_face_labeling(model)
  add_tag_from_tags!(labels,<span class=hljs-string >&quot;dirichlet&quot;</span>,[<span class=hljs-string >&quot;tag_21&quot;</span>,<span class=hljs-string >&quot;tag_22&quot;</span>])
  add_tag_from_tags!(labels,<span class=hljs-string >&quot;newmann&quot;</span>,[<span class=hljs-string >&quot;tag_23&quot;</span>,<span class=hljs-string >&quot;tag_24&quot;</span>,<span class=hljs-string >&quot;tag_25&quot;</span>,<span class=hljs-string >&quot;tag_26&quot;</span>])

  reffe = ReferenceFE(lagrangian,<span class=hljs-built_in >Float64</span>,order)
  V = TestFESpace(model,reffe;conformity=:H1,dirichlet_tags=<span class=hljs-string >&quot;dirichlet&quot;</span>)

  U = TrialFESpace(V,u)
  degree = order*<span class=hljs-number >2</span>+<span class=hljs-number >1</span>
  Ω   = Triangulation(model)
  dΩ  = Measure(Ω,degree)
  Γ   = BoundaryTriangulation(model,tags=<span class=hljs-string >&quot;newmann&quot;</span>)
  dΓ  = Measure(Γ,degree)
  n_Γ = get_normal_vector(Γ)

  f(x)   = -Δ(u)(x)
  ∇u(x)  = ∇(u)(x)
  a(u,v) = ∫( ∇(v)⋅∇(u) )*dΩ
  l(v)   = ∫( v*f )*dΩ + ∫( v*(∇u⋅n_Γ) )*dΓ
  op     = AffineFEOperator(a,l,U,V)
  ls     = LUSolver()
  solver = LinearFESolver(ls)
  uh = solve(solver,op)

  e = uh - u
  <span class=hljs-keyword >return</span> sum(∫(e⋅e)*dΩ)
<span class=hljs-keyword >end</span></code></pre>
<p>We then run the driver for different values of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> and <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span></span></span></span>, saving the values of the L2 error for each configuration.</p>
<pre><code class="julia hljs">order_vec = [<span class=hljs-number >1</span>,<span class=hljs-number >2</span>]
n_vec = [<span class=hljs-number >10</span>,<span class=hljs-number >20</span>,<span class=hljs-number >40</span>,<span class=hljs-number >80</span>]
h_vec = map(n -&gt; (<span class=hljs-number >2</span><span class=hljs-literal >π</span>/n)*(<span class=hljs-literal >π</span>/n)*(<span class=hljs-number >0.5</span>), n_vec)

error = zeros((length(order_vec),length(n_vec)))
<span class=hljs-keyword >for</span> (i,order) <span class=hljs-keyword >in</span> enumerate(order_vec)
  <span class=hljs-keyword >for</span> (j,n) <span class=hljs-keyword >in</span> enumerate(n_vec)
    error[i,j] = driver(n,order)
  <span class=hljs-keyword >end</span>
<span class=hljs-keyword >end</span></code></pre>
<p>Finally, we plot the results and compute the convergence rates.</p>
<pre><code class="julia hljs"><span class=hljs-keyword >using</span> Plots
plt = plot(xlabel=<span class=hljs-string >&quot;log10(h)&quot;</span>,ylabel=<span class=hljs-string >&quot;log10(L2 error)&quot;</span>,grid=<span class=hljs-literal >true</span>)
<span class=hljs-keyword >for</span> (i,e) <span class=hljs-keyword >in</span> enumerate(eachrow(error))
  order = order_vec[i]
  dx = log10(h_vec[<span class=hljs-number >1</span>]) - log10(h_vec[<span class=hljs-keyword >end</span>])
  dy = log10(e[<span class=hljs-number >1</span>]) - log10(e[<span class=hljs-keyword >end</span>])
  slope = string(dy/dx)[<span class=hljs-number >1</span>:<span class=hljs-number >4</span>]
  plot!(plt,log10.(h_vec),log10.(e),label=<span class=hljs-string >&quot;p = <span class=hljs-subst >$(order)</span>, slope = <span class=hljs-subst >$(slope)</span>&quot;</span>)
<span class=hljs-keyword >end</span>
<span class=hljs-meta >@show</span> plt</code></pre>
<p>The resulting plot is shown in the next figure:</p>
<p><img src="../../assets/literate_figures/poisson/convergence.png" alt="" /></p>
<p>As expected, we observe a convergence rate of order <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">p+1</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">p</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >1</span></span></span></span>.</p>

<div class=page-foot >
  <div class=copyright >
    <a href="https://github.com/gridap/GridapWorkshopNCI2023"><b>Edit this page on <img class=github-logo  src="https://unpkg.com/ionicons@5.1.2/dist/svg/logo-github.svg"></b></a><br>
    Last modified: November 20, 2023. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
  </div>
</div>
</div>
    </div>